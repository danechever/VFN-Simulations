%This script simulates pupil-plane scalar VFN by generating a vortex phase
%pattern using the segments of the Keck primary. Conducts analysis of the
%resulting coupling maps in a manner similar to that shown for a circular
%pupil in Ruane et. al. 2019. This can be done by either loading a 'seed'
%array of tilt and piston from a matlab file, or using the analytical
%solution that is generated by default.

clear; close all;
addpath(['..' filesep 'VFNlib']);

%% Input parameters 

% Define sampling info
inPar.N = 2^12; % Size of computational grid (NxN samples) 
inPar.apRad = 256; % Aperture radius in samples 
inPar.apDia0 = 2 * inPar.apRad;
inPar.keckD = 10.949; %Meters

% Define wavelength info
inPar.lambda0 = 2.2e-6; %central wavelength
inPar.fracBW = 0.1818; %\Delta\lambda/\lambda
inPar.numWavelengths = 41;% number of discrete wavelengths 
inPar.lambdas = getWavelengthVec(inPar.lambda0,inPar.fracBW,inPar.numWavelengths);% array of wavelengths (meters)

%Define charge of the vortex mask at each wavelength
%charge = ones(1,numWavelengths); % achromatic
inPar.charge = 1*(inPar.lambda0./inPar.lambdas); % simple scalar model

% Define wavefront error at the central wavelength
inPar.nolls = 4:8;
inPar.coeffs = 0*[0.01,-0.0099,-0.0095,-0.0008,0.0033];

% Give offsets for the vortex mask
inPar.offsetX = 0;%0.0952*apRad;
inPar.offsetY = 0;%0.0524*apRad; 

inPar.numRings = 3;
inPar.wGap = 25.4/10916*inPar.apDia0/2;

%Wedge Data
inPar.p = 1.2026;
inPar.wedge_mat = 'CaF2';
wedge_angle = atan((inPar.p*inPar.lambda0)/(inPar.keckD*(getRefractiveIndex(inPar.wedge_mat ,1e6*inPar.lambda0) - 1)));

%% Generate the coordinate system

coords = generateCoordinates(inPar.N);% Creates NxN arrays with coordinates
inPar.Ycoords = coords.Y;
inPar.Xcoords = coords.X;
inPar.xvals = coords.xvals;% Helpful for plotting
inPar.yvals = coords.yvals;

%% Create array with pupil function

inPar.PUPIL = makeKeckPupil(2*inPar.apRad, inPar.N );
[normI, totalPower0] = getNormalization(inPar.PUPIL); % Normalization factors
inPar.lambdaOverD = inPar.N/inPar.apRad/2; % lam/D in units of samples in the image plane
% Sinf.PUP_CRP_SZ = round(2.1*Sinf.apRad);
% Sinf.hexAmpConst = pad_crop(Sinf.hexAmpConst,Sinf.PUP_CRP_SZ);
% Sinf.hexPhzConst = pad_crop(Sinf.hexPhzConst,Sinf.PUP_CRP_SZ);

figure(1)
imagesc(inPar.xvals/inPar.apRad,inPar.yvals/inPar.apRad,inPar.PUPIL);
axis image; 
axis([-1 1 -1 1]);
title('Pupil');
colorbar; 
colormap(parula(256));
grid on;
drawnow;

% addpath(['..' filesep '..' filesep 'falco-matlab' filesep 'lib' filesep 'utils']);
% %-- Decrease matrix size in pupil plane to reduce runtime
% inputs.PUP_CRP_SZ = round(2.1*inputs.apRad);
% inputs.hexAmpConst = pad_crop(inputs.hexAmpConst,inputs.PUP_CRP_SZ);
% inputs.hexPhzConst = pad_crop(inputs.hexPhzConst,inputs.PUP_CRP_SZ);

%% Define Pupil Field without Vortex Mask
% phz = angle(inPar.PUPIL);
% 
% figure(2);
% for ch = 1:inPar.numWavelengths
% 
%     Epup(:,:,ch) = exp(1i*phz*inPar.lambda0/inPar.lambdas(ch)).*inPar.PUPIL;
% 
%     subplot(1,inPar.numWavelengths,ch);
%     imagesc(inPar.xvals/inPar.apRad,inPar.yvals/inPar.apRad,angle(Epup(:,:,ch)));
%     axis image; 
%     axis xy;
%     axis([-1 1 -1 1]);
%     title(['Phase at ',num2str(inPar.lambdas(ch)*1e9),'nm']);
%     colorbar; 
%     colormap(hsv(256));
% end

%% Define Pupil Field with Vortex Mask
phz = generateVortexMaskKeckPrimary(inPar);

figure(2);
for ch = 1:inPar.numWavelengths

    Epup(:,:,ch) = exp(1i*phz*inPar.lambda0/inPar.lambdas(ch)).*inPar.PUPIL;

    subplot(1,inPar.numWavelengths,ch);
    imagesc(inPar.xvals/inPar.apRad,inPar.yvals/inPar.apRad,angle(Epup(:,:,ch)));
    axis image; 
    axis xy;
    axis([-1 1 -1 1]);
    title(['Phase at ',num2str(inPar.lambdas(ch)*1e9),'nm']);
    colorbar; 
    colormap(hsv(256));
end
drawnow;

%% Apply Wedge Effects

figure(3);
for ch = 1:inPar.numWavelengths
    
    inPar.lam0OverD_rad = inPar.lambda0/inPar.keckD;

    wphz = generateWedgePlate(inPar,wedge_angle,inPar.lambdas(ch));
    
    phzW = phz - wphz;
    
    Epup(:,:,ch) = exp(1i*phz*inPar.lambda0/inPar.lambdas(ch)).*inPar.PUPIL;
    Epupw(:,:,ch) = exp(1i*wphz*inPar.lambda0/inPar.lambdas(ch)).*inPar.PUPIL;
    Epups(:,:,ch) = exp(1i*phzW*inPar.lambda0/inPar.lambdas(ch)).*inPar.PUPIL;
    
    subplot(1,inPar.numWavelengths,ch);
    imagesc(inPar.xvals/inPar.apRad,inPar.yvals/inPar.apRad,angle(Epupw(:,:,ch)));
    axis image; 
    axis xy;
    axis([-1 1 -1 1]);
    title(['Phase at ',num2str(inPar.lambdas(ch)*1e9),'nm']);
    colorbar; 
    colormap(hsv(256));
    
end

%% Get wavelength specific PSF WEDGE
% PSFw = getPSF(Epupw,inPar.lambda0,inPar.lambdas,normI,coords);
% 
% figure(20)
% for ch = 1:inPar.numWavelengths
%     subplot(1,inPar.numWavelengths,ch);
%     imagesc(inPar.xvals/inPar.lambdaOverD,inPar.yvals/inPar.lambdaOverD,PSFw(:,:,ch));
%     axis image;
%     axis([-2 2 -2 2]);
%     title('lambda specific PSF wedge');
%     colorbar;%caxis([-3 0])
%     colormap(parula(256));
% end
    
%% Get broadband PSF / Get Wavelength specific PSF
%iPSF_BB = getPSF(Epups,inPar.lambda0,inPar.lambdas,normI,coords);
%iPSF_BB = mean(iPSF_BB, 3);

PSF = getPSF(Epups,inPar.lambda0,inPar.lambdas,normI,coords);

figure(4)
imagesc(inPar.xvals/inPar.lambdaOverD,inPar.yvals/inPar.lambdaOverD,PSF);
axis image; 
axis([-2 2 -2 2]);
title('broadband PSF w/ vortex & wedge');
colorbar;%caxis([-3 0])
colormap(parula(256));
drawnow;

% figure(4)
% for ch = 1:inPar.numWavelengths
%     
%     subplot(1,inPar.numWavelengths,ch);
%     imagesc(inPar.xvals/inPar.lambdaOverD,inPar.yvals/inPar.lambdaOverD,PSF(:,:,ch));
%     axis image;
%     axis([-2 2 -2 2]);
%     title('lambda specific PSF w/ vortex');
%     colorbar;%caxis([-3 0])
%     colormap(parula(256));
% end

%% Generate coupling maps for each wavelength

%-- Parameters for Thorlabs SM600
%-- Using SM2000 in this version of the code
    %-- link: https://www.thorlabs.com/NewGroupPage9_PF.cfm?ObjectGroup_ID=949
fiber_props.core_rad = 5.5e-6;% Core radius [um]
fiber_props.n_core = 1.4436; %1.4571; core index (interpolated from linear fit to 3 points)
fiber_props.n_clad = 1.4381; %1.4558; cladding index (interpolated from linear fit to 3 points)
fiber_props.type = 'bessel';
Fnum = getMFD(fiber_props,inPar.lambda0)/(inPar.lambda0*1.4); % focal ratio of the beam at the fiber

eta_maps = generateCouplingMap_polychromatic( Epups, fiber_props, inPar.lambda0, Fnum, inPar.lambdas, totalPower0, inPar.lambdaOverD, 3*inPar.lambdaOverD, coords);
eta_maps_NOWEDGE = generateCouplingMap_polychromatic( Epup, fiber_props, inPar.lambda0, Fnum, inPar.lambdas, totalPower0, inPar.lambdaOverD, 3*inPar.lambdaOverD, coords);

figure(5);
for ch = 1:inPar.numWavelengths
    subplot(1,inPar.numWavelengths,ch);
    imagesc(inPar.xvals/inPar.lambdaOverD,inPar.yvals/inPar.lambdaOverD,log10(eta_maps(:,:,ch)));
    axis image; 
    axis([-2 2 -2 2]);
    caxis([-3 -0.5])
    title(['\eta at ',num2str(inPar.lambdas(ch)*1e9),'nm']);
    colorbar;
    colormap(gray(256));
end

%-- find the centroid of eta_maps(:,:,ch)
%-- find min in centroid
%-- find coordinates of this min in eta_maps
%-- plot the difference in these coordinates in x and y position from the
%   origin, with lambda corresponding to ch on the bottom and offset on the
%   left
% 
%-- Finds the radius of the centroid to crop the image to depending on the maximum eta in 1 slice
%   of eta_maps(:,:,ch)
Xshift = zeros(inPar.numWavelengths,1);
Yshift = zeros(inPar.numWavelengths,1);
etas = zeros(inPar.numWavelengths, 1);

for ch = 1:inPar.numWavelengths 
    map = eta_maps(:,:,ch); %one slice of the eta_maps cube
    map_max = max(map,[],'all'); %the maximum value in cmap
    [max_ind(1),max_ind(2)] = find(map_max==map,1); %linear coordinates of max value
    max_rho = sqrt(((inPar.N/2+1)-max_ind(1))^2 + ((inPar.N/2+1)-max_ind(2))^2);
    
    crp = 2*max_rho; %The length of one side of the cube to crop the image to

    cmap = map(end/2+1-floor(crp/2):end/2+1+floor(crp/2),end/2+1-floor(crp/2):end/2+1+floor(crp/2)); %the centroid
    cmap_min = min(cmap,[],'all'); %minimum value in the centroid
    [min_ind(1),min_ind(2)] = find(cmap_min==cmap); %indices of minimum value in the centroid
    min_ind = min_ind + (inPar.N/2-floor(crp/2)); %adjust min values to reflect position in map, not cmap
   
    Xshift(ch) = inPar.N/2-min_ind(2); %x value is wavelength, y value is offset
    Yshift(ch) = inPar.N/2-min_ind(1);%^
    
    etas(ch) = cmap_min;
end

Xshiftnw = zeros(inPar.numWavelengths,1);
Yshiftnw = zeros(inPar.numWavelengths,1);
etanw = zeros(inPar.numWavelengths, 1);
for ch = 1:inPar.numWavelengths 
    mapnw = eta_maps(:,:,ch); %one slice of the eta_maps cube
    map_maxnw = max(mapnw,[],'all'); %the maximum value in cmap
    [max_indnw(1),max_indnw(2)] = find(map_maxnw==mapnw,1); %linear coordinates of max value
    max_rhonw = sqrt(((inPar.N/2+1)-max_indnw(1))^2 + ((inPar.N/2+1)-max_indnw(2))^2);
    
    crpnw = 2*max_rhonw; %The length of one side of the cube to crop the image to

    cmapnw = map(end/2+1-floor(crpnw/2):end/2+1+floor(crpnw/2),end/2+1-floor(crpnw/2):end/2+1+floor(crpnw/2)); %the centroid
    cmap_minnw = min(cmapnw,[],'all'); %minimum value in the centroid
    [min_indnw(1),min_indnw(2)] = find(cmap_minnw==cmapnw); %indices of minimum value in the centroid
    min_indnw = min_indnw + (inPar.N/2-floor(crpnw/2)); %adjust min values to reflect position in map, not cmap
   
    Xshiftnw(ch) = inPar.N/2-min_indnw(2); %x value is wavelength, y value is offset
    Yshiftnw(ch) = inPar.N/2-min_indnw(1);%^
    
    etanw(ch) = cmap_minnw;
end

%-- Null shift plots for X, Y, and the trendlines that result
figure(6);
subplot(2,2,1);
plot(inPar.lambdas/inPar.lambda0,Xshift/inPar.lambdaOverD, '-o', 'Color', 'r');
title('Xshift');
subplot(2,2,2);
plot(inPar.lambdas/inPar.lambda0,Yshift/inPar.lambdaOverD, '-o', 'Color', 'b');
title('Yshift');

px = polyfit(inPar.lambdas/inPar.lambda0,Xshift'/inPar.lambdaOverD,1);
pxy = polyval(px,inPar.lambdas/inPar.lambda0);
subplot(2,2,3);
plot(inPar.lambdas/inPar.lambda0,pxy,'-o','Color','m')
title('X Offset Trend')
txt = ['p value: ' num2str(px)];
text(mean(inPar.lambdas/inPar.lambda0),mean(pxy),txt);

py_1 = polyfit(inPar.lambdas/inPar.lambda0,Yshift'/inPar.lambdaOverD,1);
pyy = polyval(py_1,inPar.lambdas/inPar.lambda0);
subplot(2,2,4);
plot(inPar.lambdas/inPar.lambda0,pyy,'-o','Color','g');
title('Y Offset Trend')
txt = ['p value: ' num2str(py_1)];
text(mean(inPar.lambdas/inPar.lambda0),mean(px),txt);

%-- Null value vs wavelength offset from central wavelength
figure(7);
subplot(1,1,1);
hold on;
semilogy(inPar.lambdas/inPar.lambda0,etas,'-o','Color','r'); %lambdas/lambda0,,'-o','Color','r'
semilogy(inPar.lambdas/inPar.lambda0,etanw,'-o','Color','b');
title('Null Value vs \lambda/\lambda0')
xlabel('\lambda/\lambda0')
ylabel('\eta')
grid on
hold off;

%-- Actual positional offset of null for x and y overlayed
figure(8);
plot(inPar.lambdas/inPar.lambda0,Xshift/inPar.lambdaOverD, '-o', 'Color', 'r');
hold on
plot(inPar.lambdas/inPar.lambda0,Yshift/inPar.lambdaOverD, '-o', 'Color', 'b');
legend({'Xshift', 'Yshift'}, 'Location', 'SouthEast');
title('Null Movement')
xlabel('\lambda/\lambda_0')
ylabel('Null Shift [\lambda/D]')
grid on

%-- Overlay of trends in x and y null positional offset
figure(9);
plot(inPar.lambdas/inPar.lambda0,pxy,'-o','Color','r');
hold on
plot(inPar.lambdas/inPar.lambda0,pyy,'-o','Color','b');
legend({'Xshift', 'Yshift'}, 'Location', 'SouthEast');
title('Null Movement')
xlabel('\lambda/\lambda_0')
ylabel('Null Shift [\lambda/D]')
txt = ['y trend p value: ' num2str(py_1) newline 'x trend p value: ' num2str(px)];
text(mean(inPar.lambdas/inPar.lambda0),mean(px),txt);
grid on

